"""
Separate personal standard groups.

Revision ID: 2a6c63397399
Revises: 9fd4589cc82c
Create Date: 2018-05-23 17:17:51.205891
"""

import sqlalchemy as sa
from alembic import op
from alembic.context import get_context  # noqa: F401
from sqlalchemy.dialects.postgresql.base import PGDialect
from sqlalchemy.orm.session import sessionmaker

Session = sessionmaker()

# Revision identifiers, used by Alembic.
# pylint: disable=C0103,invalid-name  # revision control variables not uppercase
revision = "2a6c63397399"
down_revision = "9fd4589cc82c"
branch_labels = None
depends_on = None

# OLD/NEW values must be different
OLD_GROUP_USERS = "user"
NEW_GROUP_USERS = "users"
OLD_GROUP_ADMIN = "admin"
NEW_GROUP_ADMIN = "administrators"
OLD_USER_USERS = OLD_GROUP_USERS
OLD_USER_ADMIN = OLD_GROUP_ADMIN

users = sa.table(
    "users",
    sa.column("id", sa.Integer),
    sa.column("user_name", sa.String),
)
groups = sa.table(
    "groups",
    sa.column("id", sa.Integer),
    sa.column("group_name", sa.String),
    sa.column("member_count", sa.Integer)
)
users_groups = sa.table(
    "users_groups",
    sa.column("user_id", sa.Integer),
    sa.column("group_id", sa.Integer),
)


def get_users_groups(db_session):
    """
    Fetch current db users and groups.
    """
    all_users = db_session.execute(sa.select([users]))
    all_groups = db_session.execute(sa.select([groups]))
    old_user_admin = [user for user in all_users if user.user_name == OLD_USER_ADMIN]
    old_user_users = [user for user in all_users if user.user_name == OLD_USER_USERS]
    old_group_admin = [group for group in all_groups if group.group_name == OLD_GROUP_ADMIN]
    old_group_users = [group for group in all_groups if group.group_name == OLD_GROUP_USERS]
    new_group_admin = [group for group in all_groups if group.group_name == NEW_GROUP_ADMIN]
    new_group_users = [group for group in all_groups if group.group_name == NEW_GROUP_USERS]
    return (
        old_user_admin[0] if len(old_user_admin) > 0 else None,
        old_user_users[0] if len(old_user_users) > 0 else None,
        old_group_admin[0] if len(old_group_admin) > 0 else None,
        old_group_users[0] if len(old_group_users) > 0 else None,
        new_group_admin[0] if len(new_group_admin) > 0 else None,
        new_group_users[0] if len(new_group_users) > 0 else None
    )


def upgrade_migrate(old_group, old_user, new_group, new_name, db_session):
    """
    Migrates a user and its personal user-group to a standard group.

    Reassigns the user references to link to the new standard group.
    """
    if new_group is None and old_group is not None:
        # just rename the group, no need to adjust references
        old_group.group_name = new_name
    elif new_group is None and old_group is None:
        # create missing group, no group reference to modify
        db_session.execute(groups.insert().values(group_name=new_name, member_count=0))
    elif new_group is not None and old_group is not None:
        # both groups exist, must transfer references
        all_usr_grp = db_session.execute(sa.select([users_groups]))
        for usr_grp in all_usr_grp:
            if usr_grp.group_id == old_group.id:
                # if user_id/group_id combination already exists, delete duplicate that would be generated by transfer
                match_new_grp = [ug for ug in all_usr_grp if ug.group_id == new_group.id]
                if len(match_new_grp) > 0:
                    db_session.delete(usr_grp)
                # otherwise transfer reference to new group
                else:
                    usr_grp.group_id = new_group.id

    # remove not required 'user-group'
    if old_user is not None:
        for usr_grp in db_session.execute(sa.select([users_groups])):
            if usr_grp.user_id == old_user.id:
                db_session.delete(usr_grp)
        db_session.delete(old_user)


def downgrade_migrate(old_group, old_user, new_group, old_name, db_session):
    """
    Migrates a standard group back to the original user and corresponding personal user-group.

    Reassigns the user references to link to the old personal group.
    """
    if old_group is None:
        # create missing group
        db_session.execute(groups.insert().value(group_name=old_name, member_count=0))
    if old_group is not None and new_group is not None:
        # transfer user-group references
        all_usr_grp = db_session.execute(sa.select(users_groups))
        for usr_grp in all_usr_grp:
            if usr_grp.group_id == new_group.id:
                # if user_id/group_id combination already exists, delete duplicate that would be generated by transfer
                match_old_grp = [ug for ug in all_usr_grp if ug.group_id == old_group.id]
                if len(match_old_grp) > 0:
                    db_session.delete(usr_grp)
                # otherwise transfer back reference to old group
                else:
                    db_session.execute(users_groups.update()
                                       .where(usr_grp.c.group_id == new_group.c.id)
                                       .values(group_id=old_group.id))

    if new_group is not None:
        db_session.delete(new_group)

    if old_user is None:
        email = "{}@mail.com".format(old_name)
        db_session.execute(users.insert().values(user_name=old_name, email=email))
        old_user = db_session.execute(sa.select(users).where(users.c.user_name == old_name)).fetchone()
        db_session.execute(users_groups.insert().values(group_id=old_group.id, user_id=old_user.id))


def clean_user_groups(db_session):
    """
    Ensures that each user is the only one pointing to it's corresponding personal user-group.

    Invalid user references are dropped.
    """
    all_users = db_session.execute(sa.select([users]))
    all_groups = db_session.execute(sa.select([groups]))
    all_usr_grp = db_session.execute(sa.select([users_groups]))

    all_usr_dict = {usr.id: usr.user_name for usr in all_users}
    all_grp_dict = {grp.id: grp.group_name for grp in all_groups}

    for usr_grp in all_usr_grp:
        # delete any missing user/group references (pointing to nothing...)
        if usr_grp.user_id not in all_usr_dict or usr_grp.group_id not in all_grp_dict:
            db_session.delete(usr_grp)
            continue
        # delete any user/personal-group reference of different names
        grp_name = all_grp_dict[usr_grp.group_id]
        usr_name = all_usr_dict[usr_grp.user_id]
        is_personal_group = usr_name in all_grp_dict.values()
        if is_personal_group and grp_name != usr_name:
            db_session.delete(usr_grp)


def upgrade():
    context = get_context()
    session = Session(bind=op.get_bind())
    if isinstance(context.connection.engine.dialect, PGDialect):
        old_usr_a, old_usr_u, old_grp_a, old_grp_u, new_grp_a, new_grp_u = get_users_groups(session)
        upgrade_migrate(old_grp_a, old_usr_a, new_grp_a, NEW_GROUP_ADMIN, session)
        upgrade_migrate(old_grp_u, old_usr_u, new_grp_u, NEW_GROUP_USERS, session)
        clean_user_groups(session)
        session.commit()


def downgrade():
    context = get_context()
    session = Session(bind=op.get_bind())
    if isinstance(context.connection.engine.dialect, PGDialect):
        old_usr_a, old_usr_u, old_grp_a, old_grp_u, new_grp_a, new_grp_u = get_users_groups(session)
        downgrade_migrate(old_grp_a, old_usr_a, new_grp_a, OLD_GROUP_ADMIN, session)
        downgrade_migrate(old_grp_u, old_usr_u, new_grp_u, OLD_GROUP_USERS, session)
        session.commit()
